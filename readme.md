# Crypto AI News Aggregator

[![Node Version](https://img.shields.io/badge/node-%3E%3D18.x-blue?logo=node.js)](https://nodejs.org/)
[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**Version:** 1.0.1 (Updated based on recent changes)

**Description:** An AI-powered news aggregator that fetches crypto-related messages from a Telegram channel, uses AI (via OpenRouter) to generate concise news articles, caches data using Redis, provides API endpoints for articles and prices, and optionally pushes updates to an external service via webhooks.

---

## Features

* **Telegram Fetching:** Monitors a specified Telegram channel for new messages.
* **AI Processing:** Uses configurable AI models via OpenRouter to summarize messages into structured news articles (headline + body). Supports fallback models.
* **Redis Caching:** Stores processed articles (up to a configurable limit) and cryptocurrency prices fetched periodically.
* **Incremental Article IDs:** Assigns a unique, sequential API ID (starting from 1000) to each processed article for stable API access.
* **Price Tracking:** Fetches cryptocurrency prices using an external service (assumed `priceService.js`).
* **Web Frontend:** Includes a simple HTML/CSS/JS frontend to display cached articles and a scrolling price ticker.
* **API Endpoints:** Provides RESTful APIs to retrieve all cached articles, a specific article by its unique API ID, and the latest cached cryptocurrency prices.
* **Webhook Notifications (Optional):** Can automatically POST updated article and price data to a configured external URL whenever changes are detected.
* **Robust Polling:** Handles fetching newer messages and backfilling older messages if the cache is below the desired article count.
* **Security:** Includes basic security middleware (Helmet, CORS) and rate limiting (global and per-IP).
* **Deployment Ready:** Configured for easy deployment on platforms like Render, Heroku, or AWS.

---

## Prerequisites

Before you begin, ensure you have the following installed and configured:

1.  **Node.js:** Version 18.x or later recommended. Download from [nodejs.org](https://nodejs.org/).
2.  **npm (or yarn):** Package manager included with Node.js.
3.  **Git:** For cloning the repository.
4.  **Redis Instance:**
    * A running Redis server (v4 or later recommended).
    * Can be run locally (e.g., via Docker: `docker run --name my-redis -p 6379:6379 -d redis`) or use a cloud provider (Redis Cloud, Render Redis, Heroku Redis, AWS ElastiCache, etc.).
    * You will need the connection URL (`REDIS_URL`).
5.  **Telegram API Credentials:**
    * `TELEGRAM_API_ID` & `TELEGRAM_API_HASH`: Obtain these by creating an app at [my.telegram.org/apps](https://my.telegram.org/apps).
    * `TELEGRAM_SESSION_STRING`: This is crucial for authenticating the Telegram client library.
        * **How to Generate:** This string is usually generated by running an interactive script using the `telegram` library that prompts you for your phone number, login code, and potentially 2FA password.
        * **You will likely need to create a separate, temporary Node.js script** to do this. Search online for "telegram library nodejs session string generation" for examples relevant to the version used (`telegram` v2.x). A basic script might look like:
            ```javascript
            // Example temporary script (save as generateSession.js, run with node generateSession.js)
            import { TelegramClient } from 'telegram';
            import { StringSession } from 'telegram/sessions/index.js';
            import input from 'input'; // npm install input

            const apiId = YOUR_API_ID; // Replace with your actual API ID
            const apiHash = 'YOUR_API_HASH'; // Replace with your actual API Hash
            const stringSession = new StringSession(''); // Start with empty session

            (async () => {
              console.log('Loading interactive example...');
              const client = new TelegramClient(stringSession, apiId, apiHash, { connectionRetries: 5 });
              await client.start({
                phoneNumber: async () => await input.text('Enter phone number: '),
                password: async () => await input.text('Enter 2FA password: '),
                phoneCode: async () => await input.text('Enter code received: '),
                onError: (err) => console.error(err),
              });
              console.log('You should now be connected.');
              console.log('Save this session string to your .env file:');
              console.log(client.session.save()); // Outputs the session string
              await client.disconnect();
            })();
            ```
        * **Security:** Treat this session string like a password; keep it secure in your `.env` file and environment variables. Do NOT commit it to Git. It may expire periodically (e.g., monthly), requiring regeneration.
6.  **OpenRouter API Key(s):**
    * Get API keys from [openrouter.ai/keys](https://openrouter.ai/keys). You can use multiple keys (comma-separated) for potential load balancing or fallback.

---

## Environment Variables

Create a `.env` file in the project root by copying `.env.example` (`cp .env.example .env`). Fill in your actual credentials and settings.

```dotenv
# .env - Main Configuration File

# ==============================================
#             REQUIRED SETTINGS
# ==============================================

# ----- Telegram API Credentials -----
TELEGRAM_API_ID=your_telegram_app_id_here
TELEGRAM_API_HASH=your_telegram_app_hash_here
TELEGRAM_SESSION_STRING=your_telegram_session_string_here # Generated via helper script (see Prerequisites)

# ----- Telegram Channel -----
TELEGRAM_CHANNEL=your_target_channel_username_or_id # Public username or private ID (e.g., -100...)

# ----- AI Service Configuration -----
OPENROUTER_API_KEYS=your_openrouter_key1,your_openrouter_key2 # Comma-separated keys from openrouter.ai
OPENROUTER_MODELS=meta-llama/llama-3-70b-instruct           # Primary AI model(s) from OpenRouter
OPENROUTER_FALLBACK_MODELS=google/palm-2-chat-bison,anthropic/claude-3-haiku # Fallback models

# ----- Redis Connection -----
REDIS_URL=redis://:your_redis_password@your_redis_host:your_redis_port # e.g., redis://localhost:6379 for local

# ==============================================
#            APPLICATION SETTINGS
# ==============================================

# ----- Core Functionality -----
CRYPTO_SYMBOLS=BTC:bitcoin,ETH:ethereum,SOL:solana # Symbol:CoinGeckoID pairs for price fetching
MESSAGE_FETCH_LIMIT=25                          # Telegram messages to fetch per poll cycle (Default: 25)
PROCESSING_LOCK_TTL=60                          # Lock duration (seconds) for message processing (Default: 60)

# ----- Branding & Display -----
SITE_NAME="Crypto AI News"                      # Used in API headers (Default: Crypto AI News)
SITE_URL=[https://your-app-name.onrender.com](https://www.google.com/search?q=https://your-app-name.onrender.com)     # Your app's public URL (used for CORS, API headers) - IMPORTANT: Set this!

# ----- Performance & Hosting -----
PORT=3000                                       # Server port (Default: 3000, often overridden by host)
NODE_ENV=production                             # 'production' recommended for deployment
PROXY_TRUST_LEVEL=1                             # Trust level for proxy headers (e.g., 1 for Render/Heroku) (Default: 1)

# ----- Price Tracking Service -----
PRICE_POLL_INTERVAL=60000                       # Price fetch interval (ms) (Default: 60000 = 1 min)
PRICE_HISTORY_LIMIT=1440                        # Max price points per symbol (Default: 1440 = 24h if 1min interval)

# ----- Webhook Notification Service (Optional) -----
WEBHOOK_TARGET_URL=                             # URL to POST updates to (leave empty to disable)
WEBHOOK_INTERVAL_MINUTES=1                      # Check interval (minutes) (Default: 1)
# WEBHOOK_AUTH_TOKEN=your_secret_token          # Optional: Auth token if webhook target needs it (implement header in webhookService.js)

# ==============================================
#            MAINTENANCE SETTINGS
# ==============================================

# ----- Redis Maintenance -----
DO_FLUSH_REDIS=false                            # WARNING: Set true ONLY for first deploy/wipe, then false (Default: false)
```

---

## API Endpoints

The application exposes the following REST API endpoints:

1.  **GET `/api/cached-articles`**
    * **Description:** Retrieves the list of all currently cached articles. Articles are sorted by Telegram message ID descending (newest message first).
    * **Response Body:** `Array<Article>`
        * `Article` Object Structure:
            ```json
            {
              "id": 12345, // Original Telegram Message ID
              "apiId": 1001, // Unique, Sequential API ID (number)
              "headline": "Example Headline",
              "article": "Generated article content...",
              "source": "[https://original-source.url/](https://original-source.url/)...",
              "date": "2025-04-07T09:53:20.123Z", // ISO 8601 Date string
              "status": "processed"
            }
            ```

2.  **GET `/api/articles/:apiId`**
    * **Description:** Retrieves a single article by its unique, sequential `apiId` (the number assigned during processing, starting from 1000).
    * **URL Parameter:** `apiId` (number) - The sequential API ID of the desired article.
    * **Success Response (200 OK):** `{ "success": true, "data": Article }`
    * **Error Responses:**
        * `400 Bad Request`: If `apiId` is not a valid number. (`{ "success": false, "error": "Invalid API ID format - must be a number" }`)
        * `404 Not Found`: If no article with the given `apiId` exists in the cache. (`{ "success": false, "error": "Article not found for the given API ID" }`)
        * `500 Internal Server Error`: If there's a server-side issue fetching data.

3.  **GET `/api/cached-prices`**
    * **Description:** Retrieves the latest cached prices for the symbols defined in the `CRYPTO_SYMBOLS` environment variable.
    * **Response Body:** `Object` - A key-value map where keys are the crypto symbols (e.g., "BTC", "ETH") and values are their latest price (number) or `null` if unavailable.
        ```json
        {
          "BTC": 69420.50,
          "ETH": 3450.12,
          "SOL": null
        }
        ```

---

## Webhook Service (Optional)

If `WEBHOOK_TARGET_URL` is configured in your environment variables, the application will periodically check for updates to articles and prices.

* **Trigger:** Runs every `WEBHOOK_INTERVAL_MINUTES` (default 1 minute).
* **Condition:** Sends a POST request *only if* new articles have been added (detected by checking the latest Telegram message ID in the cache) OR if the cached cryptocurrency prices have changed (detected by comparing content hashes) since the last successful webhook post.
* **Endpoint:** Sends a `POST` request to the URL specified in `WEBHOOK_TARGET_URL`.
* **Payload:** The request body is a JSON object containing:
    ```json
    {
      "allArticles": [ ... ],  // Array of all currently cached Article objects
      "latestArticle": { ... }, // The most recently processed Article object (or null if cache is empty)
      "latestPrices": [ ... ]   // Array of latest price objects (structure depends on priceService.js)
    }
    ```
* **Headers:** `Content-Type: application/json`. (You may need to modify `webhookService.js` to add authentication headers like `Authorization` if your target requires it).
* **Purpose:** Allows you to push data updates to other services, trigger downstream workflows, or update external databases/frontends automatically.

---

## Local Setup

1.  **Clone:** `git clone <your-repo-url>`
2.  **Navigate:** `cd <repo-folder>`
3.  **Install:** `npm install`
4.  **Configure:** `cp .env.example .env` and edit `.env` with your credentials (see Environment Variables section and Prerequisites for session string generation).
5.  **Start Redis:** Ensure your local or remote Redis instance is running and accessible via the `REDIS_URL`.
6.  **(Optional) Pre-start Check:** `npm run prestart` (shows warnings based on `.env`).
7.  **Run (Development):** `npm run dev`
    * This uses `nodemon` to automatically restart the server on file changes.
8.  **Run (Production Simulation):** `npm start`
9.  **Access:** Open `http://localhost:3000` (or your configured `PORT`).

---

## Deployment

**Key Steps for Any Provider:**

1.  **Push Code:** Ensure your latest code is committed and pushed to your Git repository (GitHub, GitLab, etc.).
2.  **Provider Setup:** Create a Web Service/App instance on your chosen platform (Render, Heroku, AWS EB, etc.). Link it to your Git repository.
3.  **Build Command:** Set the build command (usually `npm install`).
4.  **Start Command:** Set the start command to `node server.js`.
5.  **Provision Redis:** Create a Redis instance via your provider's addons/marketplace or use an external one. Get its connection URL.
6.  **Configure Environment Variables:** This is CRUCIAL. Add *all* required variables from the `.env` section above to your provider's environment variable settings.
    * Use the Redis connection URL obtained in step 5 for `REDIS_URL`.
    * Set `NODE_ENV=production`.
    * Set `SITE_URL` to your application's public URL provided by the host.
    * Set `WEBHOOK_TARGET_URL` if using the webhook feature.
    * Set `DO_FLUSH_REDIS=true` **only for the very first deployment** if you need a clean start.
7.  **Deploy:** Trigger the deployment.
8.  **(IMPORTANT) Update `DO_FLUSH_REDIS`:** After the first successful deploy, immediately change the `DO_FLUSH_REDIS` environment variable to `false` to prevent accidental data wipes on future deploys.

**1. Render.com**

1.  **Create Account:** Sign up or log in at [render.com](https://render.com/).
2.  **Create Redis:**
    * Go to "Blueprints" or "New +" -> "Redis".
    * Choose a plan (e.g., free tier for testing).
    * Once created, copy the **"Internal Redis URL"**.
3.  **Create Web Service:**
    * Go to "New +" -> "Web Service".
    * Connect your Git repository (GitHub, GitLab, etc.).
    * **Settings:**
        * **Name:** Choose a name (e.g., `cryptonews-app`).
        * **Region:** Select a region close to you or your users.
        * **Branch:** `main` (or your deployment branch).
        * **Root Directory:** `/` (if `package.json` is in the root).
        * **Build Command:** `npm install`
        * **Start Command:** `node --experimental-network-imports server.js` (The `prestart` script runs automatically before `start`)
        * **Instance Type:** Choose a plan (e.g., free tier).
4.  **Add Environment Variables:**
    * Go to the "Environment" tab for your Web Service.
    * Add all the variables from the `.env` section above. Use the **Internal Redis URL** copied earlier for `REDIS_URL`.
    * Set `SITE_URL` to your Render service URL (e.g., `https://cryptonews-app.onrender.com`).
    * Set `NODE_ENV=production`.
    * Set `DO_FLUSH_REDIS=true` for the first deploy.
5.  **Deploy:** Click "Create Web Service".
6.  **Update `DO_FLUSH_REDIS`:** After the first deployment succeeds, go back to Environment Variables and change `DO_FLUSH_REDIS` to `false`. Redeploy if necessary.

**2. Heroku**

1.  **Create Account & Install CLI:** Sign up at [heroku.com](https://heroku.com/) and install the [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli).
2.  **Login:** `heroku login`
3.  **Create App:** `heroku create your-app-name` (or `heroku create` for a random name).
4.  **Add Redis:** `heroku addons:create heroku-redis:mini` (or choose a different plan). This automatically sets the `REDIS_URL` config var.
5.  **Set Environment Variables:**
    * Use the Heroku CLI or the Dashboard (Settings -> Config Vars).
    * `heroku config:set TELEGRAM_API_ID=YOUR_API_ID TELEGRAM_API_HASH=YOUR_API_HASH ...`
    * Add all variables from the `.env` section *except* `REDIS_URL` (it's set by the addon).
    * Set `SITE_URL` to your Heroku app URL (e.g., `https://your-app-name.herokuapp.com`).
    * Set `NODE_ENV=production`.
    * Set `DO_FLUSH_REDIS=true` for the first deploy.
6.  **Deploy:**
    * Commit your code: `git add .`, `git commit -m "Prep for Heroku"`
    * Push to Heroku: `git push heroku main` (or your branch name). Heroku automatically detects Node.js and runs `npm start`.
7.  **Update `DO_FLUSH_REDIS`:** After the first deploy, use `heroku config:set DO_FLUSH_REDIS=false` or the dashboard to update the variable.

**3. AWS (Elastic Beanstalk)**

*Note: This is more complex than Render/Heroku.*

1.  **Create Account & Setup:** Sign up at [aws.amazon.com](https://aws.amazon.com/). You might need to configure AWS CLI locally.
2.  **Create ElastiCache Redis:**
    * Go to the AWS ElastiCache console.
    * Create a Redis cluster (e.g., `cache.t3.micro` for testing).
    * Configure security groups to allow inbound connections from your future Elastic Beanstalk environment's security group (on port 6379).
    * Note the **Primary Endpoint** URL for your Redis cluster.
3.  **Prepare Code:** Zip your project files (excluding `node_modules` and `.env`).
4.  **Create Elastic Beanstalk Application & Environment:**
    * Go to the Elastic Beanstalk console.
    * Create a new Application.
    * Create a new Environment within the application.
        * **Platform:** Select "Node.js".
        * **Application code:** Upload your zip file.
5.  **Configure Environment:**
    * Go to your Environment -> Configuration -> Software -> Environment properties.
    * Add all the environment variables from the `.env` section.
    * For `REDIS_URL`, construct it using the ElastiCache Primary Endpoint (e.g., `redis://your-redis-endpoint.xxxxxx.cache.amazonaws.com:6379`). If you enabled authentication, include the password.
    * Set `SITE_URL` to your Elastic Beanstalk environment URL.
    * Set `NODE_ENV=production`.
    * Set `DO_FLUSH_REDIS=true` for the first deploy.
    * Ensure the `npm start` command is used (usually the default for Node.js platforms).
6.  **Configure Security Groups:**
    * Ensure the Elastic Beanstalk environment's security group can access the ElastiCache Redis security group on port 6379.
    * Ensure the EB security group allows inbound traffic on HTTP/HTTPS (port 80/443).
7.  **Deploy:** The environment should build and deploy automatically after creation/configuration.
8.  **Update `DO_FLUSH_REDIS`:** After the first deploy, update the environment property to `false`.

---

## Connecting a Custom Domain

**General Steps:**

1.  **Domain Registrar:** Purchase a domain name from a registrar (e.g., GoDaddy, Namecheap, Google Domains).
2.  **Hosting Provider:** Add your custom domain to your hosting platform (Render, Heroku, AWS). They will provide you with a target URL/value (often a CNAME target like `your-app.onrender.com` or similar).
3.  **DNS Configuration:** Go to your domain registrar's DNS management panel.
    * **For `www` subdomain (e.g., `www.yourdomain.com`):** Create a `CNAME` record.
        * **Type:** `CNAME`
        * **Name/Host:** `www`
        * **Value/Target:** The target URL provided by your hosting platform (e.g., `your-render-service.onrender.com`, `your-heroku-dns-target.herokudns.com`).
    * **For root domain (e.g., `yourdomain.com`):**
        * If your registrar supports `ALIAS`, `ANAME`, or `CNAME Flattening`, use that record type.
            * **Type:** `ALIAS` or `ANAME`
            * **Name/Host:** `@` (or leave blank, depending on registrar)
            * **Value/Target:** The target URL provided by your hosting platform.
        * If not, you might need to use URL forwarding/redirects (less ideal) or point an `A` record to an IP address provided by your host (check their specific instructions).
4.  **SSL/HTTPS:** Your hosting provider (Render, Heroku, AWS via Load Balancer/CloudFront) usually handles automatic SSL certificate provisioning for custom domains added through their interface. Ensure `FORCE_HTTPS=true` is set if your provider handles the redirection.
5.  **Wait for Propagation:** DNS changes can take time (minutes to hours) to take effect globally.
6.  **Update `SITE_URL`:** Update the `SITE_URL` environment variable in your deployment to reflect your new custom domain (e.g., `https://www.yourdomain.com`).

---

## Troubleshooting

* **Redis Errors (`ECONNREFUSED`, `ETIMEDOUT`, `NOAUTH`, `READONLY`):** Check `REDIS_URL`, firewall/security groups, password. Ensure Redis isn't in read-only mode (can happen on free tiers). Test with `redis-cli -u $REDIS_URL PING`.
* **Telegram Errors (`AUTH_KEY_UNREGISTERED`, `SESSION_REVOKED`, connection issues):** Likely an invalid or expired `TELEGRAM_SESSION_STRING`. Regenerate it (see Prerequisites). Check API ID/Hash. Check network connectivity.
* **AI Errors (`4xx`, `5xx`, timeouts):** Check `OPENROUTER_API_KEYS`. Ensure models in `OPENROUTER_MODELS` / `OPENROUTER_FALLBACK_MODELS` are valid and accessible on OpenRouter. Check OpenRouter status and your account limits. Increase `MODEL_TIMEOUT` in `openai.js` if needed (though it's currently hardcoded).
* **Webhook Errors (`4xx`, `5xx`, timeouts):** Verify `WEBHOOK_TARGET_URL` is correct. Check if the target URL requires authentication (add header in `webhookService.js`). Check logs in `webhookService.js` for detailed error messages from `axios`. Ensure the target service is running and accessible.
* **Article ID Issues:** Check Redis key `article_api_id_counter` exists and is a number. Ensure `telegramService.js` successfully increments it via `redisClient.incr`.
* **Rate Limiting (HTTP 429):** Check application logs. Ensure `PROXY_TRUST_LEVEL` is correct for your hosting setup. Consider adjusting limits in `security.js` if legitimate traffic is blocked.
* **App Crashes:** Check logs for `uncaughtException`. Verify all required environment variables are set and accessible within the Node process.
* **Frontend Not Loading Data:** Check browser console (F12) for errors. Check network tab for failed API calls (`/api/...`). Ensure backend is running, Redis has data, and CORS (`SITE_URL`) is configured correctly.

---

## Maintenance

* **Regularly:** Monitor logs for errors (Telegram, AI, Redis, Webhook).
* **Periodically:** Regenerate `TELEGRAM_SESSION_STRING` as it can expire.
* **As Needed:** Update Node.js and dependencies (`npm update`, `npm audit fix`) after testing. Review AI model choices on OpenRouter. Check Redis memory usage.

---

## License

MIT License. See the `LICENSE` file.
